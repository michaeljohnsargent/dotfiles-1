set nocompatible
set laststatus=2
"let g:solarized_termcolors=256
"set t_Co=16
"set background=dark
"colorscheme solarized

set t_Co=256
colorscheme nick-railscasts

:set guifont=Monaco:h12
:set guioptions-=T

:set nowrap

"set clipboard+=unnamed " share system clipboard

set cursorline " highlight the current line
"set cursorcolumn " highlight the current column
:nnoremap <Leader>c :set cursorline!<CR>
":nnoremap <Leader>c :set cursorline! cursorcolumn!
:nnoremap <Leader>3 :set number!<CR>

filetype on
filetype plugin on
filetype indent on
syntax on

"Mappings {
inoremap jj <esc>
map 0 ^
map ; $
map <C-j> <C-W>j
map <C-k> <C-W>k
map <C-h> <C-W>h
map <C-l> <C-W>l
map <Space> i
" }

"NERDTree options {
let NERDTreeWinPos  = 'right'
let NERDTreeWinSize = 40
"let NERDTreeIgnore  =   ['\.pyc$','\.swp$', '\.log$']
"}
autocmd VimEnter * NERDTreeClose
"autocmd VimEnter * wincmd p

"Strip trailing whitespace {
fun! <SID>StripTrailingWhitespaces()
  let l = line(".")
  let c = col(".")
  %s/\s\+$//e
  call cursor(l, c)
endfun

autocmd BufWritePre *.rb :call <SID>StripTrailingWhitespaces()
autocmd BufWritePre *.yml :call <SID>StripTrailingWhitespaces()
autocmd BufWritePre *.erb :call <SID>StripTrailingWhitespaces()
autocmd BufWritePre *.haml :call <SID>StripTrailingWhitespaces()
autocmd BufWritePre *.rabl :call <SID>StripTrailingWhitespaces()
autocmd BufWritePre *.js :call <SID>StripTrailingWhitespaces()
autocmd BufWritePre *.css :call <SID>StripTrailingWhitespaces()
autocmd BufWritePre *.rake :call <SID>StripTrailingWhitespaces()
autocmd BufWritePre Gemfile :call <SID>StripTrailingWhitespaces()
autocmd BufWritePre Guardfile :call <SID>StripTrailingWhitespaces()
autocmd BufWritePre Guardfile.example :call <SID>StripTrailingWhitespaces()
" }

" Vim-doc {
let g:ruby_doc_command='open'
let g:ruby_doc_ruby_mapping='RB'
let g:ruby_doc_rails_mapping='RR'
let g:ruby_doc_rspec_mapping='RS'
let g:jquery_doc_command='open'
let g:jquery_doc_mapping='JJ'
" }

" Vim Powerline status bar
set encoding=utf-8
let g:Powerline_symbols = 'fancy'

function! DoPrettyXML()
    " save the filetype so we can restore it later
    let l:origft = &ft
    set ft=
    " delete the xml header if it exists. This will
    " permit us to surround the document with fake tags
    " without creating invalid xml.
    1s/<?xml .*?>//e
    " insert fake tags around the entire document.
    " This will permit us to pretty-format excerpts of
    " XML that may contain multiple top-level elements.
    0put ='<PrettyXML>'
      $put ='</PrettyXML>'
      silent %!xmllint --format -
    " xmllint will insert an <?xml?> header. it's easy enough to delete
    " if you don't want it.
    " delete the fake tags
    2d
    $d
    " restore the 'normal' indentation, which is one extra level
    " too deep due to the extra tags we wrapped around the document.
    silent %<
    " back to home
    1
    " restore the filetype
    exe "set ft=" . l:origft
endfunction
command! PrettyXml call DoPrettyXML()
